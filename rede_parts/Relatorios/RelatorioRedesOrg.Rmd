---
title: "RelatorioRedesOrg"
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 3
    number_sections: true
    
date: "`r Sys.Date()`"
---

```{r setup, include = FALSE}
#working directory
knitr::opts_knit$set(root.dir = here::here())

## Carregando pacotes
library(tidyverse)
library(igraph)
```

# A fazer no relatório
- colapsar orgs sucessoras p/ análise de centralidade MMA etc no tempo
- idem p/ teste com ONGs?
- visualização das redes (mandato e década)
- rodar cálculo centralidade p/ décadas
- fazer estatísticas descritivas da rede (total, década, janelas 3 e 4 anos)

# Preparo dos dados

## Versão do banco
Relatório mais recente: "`r Sys.Date()`"
```{r get_latest function, include=FALSE}

setwd("C:/Users/marti/Documents/Doutorado/controle_doc/BD_deleg-evento")

get_latest <- function(basefilename){
  file_name <- list.files(pattern = paste0(basefilename, "-.+\\.csv"))
  date <- stringr::str_remove_all(file_name, paste0(basefilename,"-", "|\\.csv"))
  max(as.Date(date)) #if multiple results, return most recent date
}

latest_deleg <- get_latest("deleg")
latest_orgs <- get_latest("orgs")
latest_class <- get_latest("class")
latest_eventos <- get_latest("eventos")
```

**Versão da planilha deleg**: `r latest_deleg`

**Versão da planilha orgs**: `r latest_orgs`

**Versão da planilha class**: `r latest_class`

**Versão da planilha eventos**: `r latest_eventos`

**Versão da planilha individuos**: `r get_latest("individuos")`

```{r preparo bases deleg-eventos, include = FALSE}

getlatest_file <- function(basefilename#, folder = here::here("BD_deleg-evento")
                           ){
  list.files(#path = folder, 
             pattern = paste0(basefilename, "-.+\\.csv")) -> file_list

  if(length(file_list) == 1) {return(file_list)} 
  else{
    last_date <- stringr::str_remove_all(file_list, 
                                         paste0(basefilename,
                                                "-", "|\\.csv")) %>%
      as.Date %>% max()
    last_date

    list.files(pattern = paste0(basefilename, "-", last_date,
                                ".csv"))
  }
  
}

setwd("C:/Users/marti/Documents/Doutorado/controle_doc/BD_deleg-evento")


# Importar eventos e organizar 
# abrir planilha eventos e organizar dados
eventos <- read_delim(getlatest_file("eventos"),
                      ";", escape_double = FALSE, 
                      #locale = locale(encoding = "UTF-8"), 
                      trim_ws = TRUE)

eventos <- eventos %>%
  rename(#renomeia colunas
    conf = `Nome do evento`,
    conference = `Conf/Conv`,
    tema = `Regime/Tema`,
    data = Data,
    location = Locale,
    tipo_evento = `Tipo evento`,
    infMEA_list = `Lista MEA?`,
    coleta = `Coleta?`,
    proces = `Proces.?`
  ) %>%
  filter(is.na(data)==F) %>%
  select(conf, conference, tema, data) #no momento, só me interessam essas

eventos <- eventos %>% mutate(
  data = if_else(str_count(data)==4, #se falta o mês (só ano)
                 paste0(data, "-01"), #padroniza como janeiro
                 data)) %>%
  mutate(
    data = if_else(is.na(data)== F,
                   paste0(data, "-01"), #padroniza data no dia 1 do mês
                   data)
  ) %>% mutate(data = ymd(data), 
               ano = year(ymd(data)))

eventos$id_evento <- 1:nrow(eventos) #criar id numérico evento


# Importar delegs
delegs <- read_delim(getlatest_file("deleg"), 
                    ";", escape_double = FALSE, 
                    col_types = cols(
                      #X1 = col_skip()
                      ), 
                    #locale = locale(encoding = "ISO-8859-1"), 
                    trim_ws = TRUE)


# Importar orgs
orgs <- read_delim(getlatest_file("orgs"), 
                    ";", escape_double = FALSE, 
                    col_types = cols(
                      #X1 = col_skip()
                      ), 
                    #locale = locale(encoding = "ISO-8859-1"), 
                    trim_ws = TRUE) %>% distinct()

# Importar class
class <- read_delim(getlatest_file("class"), 
                    ";", escape_double = FALSE, 
                    col_types = cols(
                      #X1 = col_skip()
                      ), 
                    locale = locale(encoding = "ISO-8859-1"), 
                    trim_ws = TRUE) %>% distinct()

```


```{r preparo base individuos, include=FALSE}

individuos <- read_csv(getlatest_file("individuos"), 
                       col_types = cols(padrao_antigo = col_skip()#,
                                        #nrow = col_skip()
                                        )
                       )

# criar id numérico p/ cada indivíduo e cd individuo-evento
# Individual-Event Id (one for each participation of the individual in event)
delegs$id_indevento <- 1:nrow(delegs)

# Individual Id (permanent individual id shared across events)
individuos %>% select(nome_padrao) %>% distinct() %>% mutate(
  id_individuo = row_number() #create id for each individual
) %>% right_join(individuos, multiple = 'all') -> individuos

```

```{r preparo rede ind dinamica, include =FALSE}
# Joining the databases -----
# Data on individuals (standardize participant names and include ids)
matriz_part_evento <- left_join(delegs, individuos) %>% 
  select(-c(nome, id_org_dupla, nome_padrao))
# Data on events (include data on the events)
matriz_part_evento <- left_join(matriz_part_evento, 
                                select(eventos, c(conf, id_evento))
) %>% select(-conf)

  # Resulting dataframe only includes numerical ids

# List of events that have participants (as some lack Brazilian delegations)
lista_eventos_comdeleg <- matriz_part_evento$id_evento

# Generating a new incidence matrix -------

incidence_matrix <- matriz_part_evento %>% 
select(id_indevento, id_evento) %>% # use data of individuals and events
  table() # count if there is data in each combination of individual and event
class(incidence_matrix) <- "matrix" # converts the dataframe into matrix object

# Creating a unipartite projection ------
#.... Projecting an IndYear-IndYear Network -----
# IndYear-IndYear Matrix through cross-Product Method
matriz_ind_ano <- incidence_matrix %*% t(incidence_matrix)

# We can calculate matrix diagonal, giving us n of events per individual-year
personyr_n_of_events <- diag(matriz_ind_ano)

# Before creating the network projection, diagonal should be zeroed 
# If we don't do that, there will be loops for the nodes in the projection
diag(matriz_ind_ano) <- 0

# Network: indiv projection as nodes, coparticipation as edges and weight
# (more coparticipation = more weight)
personyrNet <- graph.adjacency(matriz_ind_ano, mode = "undirected",
                             weighted = TRUE)

# Including attributes in the network -----------
# For easier manipulation, will include as dataframe, not as igraph object
node_list <- as_data_frame(personyrNet, "vertices")

# Include other ids (individual and event)
node_list$id_indevento <- as.integer(node_list$name)
node_list$id_individuo <- matriz_part_evento[#id indivíduo
  node_list$id_indevento==matriz_part_evento$id_indevento,
]$id_individuo

node_list$id_evento <- matriz_part_evento[#id evento
  node_list$id_indevento==matriz_part_evento$id_indevento,
]$id_evento

# include individual name (nome padrao)
individuos_unico <- individuos %>% select(-nome) %>% distinct()
node_list <- left_join(node_list, individuos_unico)

# include year of participation in event
node_list <- left_join(node_list,
                       select(eventos, c(id_evento, ano))) %>% 
  rename(ano_part = ano)

# include number of participations in events per individual
node_list$nparticipations <- personyr_n_of_events[
   node_list$id_indevento==names(personyr_n_of_events)]

#.... Including info on organizations -----
orgs <- distinct(orgs)
class <- class %>% filter(is.na(id_org_unica) == F) %>% distinct()

# joining the databases
chave_orgs <- left_join(select(delegs, c(id_indevento, id_org_dupla)),
                        orgs
) %>% left_join(class) %>% distinct()


# Include organization data in node list
node_list <- left_join(node_list, chave_orgs)
node_list$id_org_dupla <- NULL

##.... Including year and issue as edge attributes ------
edge_list <- as_data_frame(personyrNet, "edges")

# Including event id
edge_list$id_indevento <- as.integer(edge_list$from)
edge_list <- left_join(edge_list, 
                       select(matriz_part_evento, c(id_indevento, id_evento))
)

# Including event info
edge_list <- left_join(edge_list, eventos) %>%
  select(-c(data, id_indevento))

#.... Remaking the network ----
personyrNet <- graph_from_data_frame(edge_list, directed = FALSE,
                                   vertices = node_list
)



# clear up some space
rm(matriz_ind_ano)
rm(incidence_matrix)
rm(personyr_n_of_events)
```



## ORGANIZATIONS COLLAPSED NETWORK
We need to transform the ind-year network into org net. While this represents an inevitable loss of information, it should also help in interpreting and discerning structures.

At this point of the research, we are not interested in a full picture of organizations (ie, covering the whole period). We will first filter the period of interest, then collapse to orgs. This should avoid some problems (e.g. allowing us to properly filter
by org info such as n of events attended on that period, not complete database)

```{r funcoes para simplificar rede, include=FALSE}
yearfilter_net <- function(net, min, max){
  net <- induced_subgraph(net,
                          V(net)[ano_part >= min & ano_part <= max])
  net
}

collapse_ind2org <- function(indyearnet){
  org_list <- unique(V(indyearnet)$org_limpo)
  
  org_yrnet <- contract(indyearnet,
                        mapping = as.numeric(
                          plyr::mapvalues(V(indyearnet)$org_limpo, 
                                          from = org_list, 
                                          to = 1:length(org_list))
                        ),
                        vertex.attr.comb=list(#methods for combining attributes
                          weight="sum", #sum weights,
                          nparticipations = "sum",  #sum nparticipations
                          "first")) # keep first of others
  
  org_yrnet <- simplify(org_yrnet) # sum weights to simplify network
  
  # Remove vertex of org No Info (id-org-unica = 565), as they are not
  # really the same organization and this distorts data.
  org_yrnet <- delete_vertices(org_yrnet, V(org_yrnet)$id_org_unica == 565)
  
  # As we now collapsed as organizations, various attributes stop making sense
  # Let's remove them to avoid misiterpretation and clean up space
  attrs_to_remove <- c("id_indevento", "id_individuo",
                       "id_evento", "nome_padrao", "ano_part")
  
  for (i in seq_along(attrs_to_remove)){
    print(attrs_to_remove[i])
    org_yrnet <- remove.vertex.attribute(org_yrnet, attrs_to_remove[i])
  }
  org_yrnet
}
```

```{r funcao calculo centralidade, include=FALSE}
# function to calculate centrality at the networks for selected orgs
central_stats <- function(orgdecadenet, measure, lglnormal = F, decade,
                          invertweight = F){
  
  df <- data.frame(#ids for mre, mma, mapa, mct 
    name = V(orgdecadenet)[V(orgdecadenet)$id_org_unica %in% c(435, 442, 421, 422)]$name,
    org = V(orgdecadenet)[V(orgdecadenet)$id_org_unica %in% c(435, 442, 421, 422)]$org_limpo
  )
  
  if(invertweight){E(orgdecadenet)$weight <- 1/E(orgdecadenet)$weight}
  
  if(measure == "betweenness"){
    stats <- betweenness(orgdecadenet, directed = F,
                         normalized = lglnormal) #calculate for all
  }else if(measure == "closeness"){
    stats <- closeness(orgdecadenet, normalized = lglnormal)
  }else if(measure == "eigenvector"){
    lglnormal <- NA
    stats <- eigen_centrality(orgdecadenet)$vector
  }else if(measure == "pagerank"){
    lglnormal <- NA
    stats <- page_rank(orgdecadenet)$vector
  }
  
  # only keep values for selected orgs
  stats <- data.frame(name = names(stats), value = stats)
  stats <- add_row(stats, name = "avg", value = mean(stats$value)) %>% 
    filter(name %in% df$name | name == "avg") %>% left_join(df)
  
  # include labels of calculation
  stats$measure <- measure
  stats$decade <- decade
  stats$normalized <- lglnormal
  stats$weightinverted <- invertweight
  stats
}
```


# Visualizando e calculando centralidade em diferentes recortes de período

## Preparando p/ visualização

As there are too many categories of organization in total (24), we will use the simplified categorization (10). This allows us to better compare across figures.

Segue a lista usada: "Other","Business","Federal Gov (non MFA)", "Subnational", "Civil Society", "Academia", "Parliament", "Not identified", "MFA"

```{r paleta simplificada, include=FALSE}
###.... Preparing a pallette based on type ----
types <- class %>% select(tipo_org_reduzido) %>% distinct() %>% 
  filter(is.na(tipo_org_reduzido)==F)

pallette <- RColorBrewer::brewer.pal(9, "Set1") %>% rev()
types$color <- pallette
types$label <- c("Other","Business","Federal Gov (non MFA)",
                 "Subnational","Civil Society","Academia",
                 "Parliament","Not identified","MFA")
```

Criamos uma função para preparar os vértices pra visualização. Calcula-se a centralidade do nó (só aparece nome da org se alta centralidade); Atribui-se o peso às arestas (invertido, porque igraph trabalha com lógica de peso como custo e queremos peso como força)
```{r preparo aparencia vertice, include=FALSE}
preparing_nodeappearance <- function(orgdecadenet, nlabelstoshow){
  #.... Calculating node centrality
  
  # We will use betweenness centrality here, as we are particularly interested
  # in the influence/capacity of orgs to mediate/control the flow of information
  
  org_betw <- betweenness(orgdecadenet)
  
  # # Only show label if node is among the top largest degree
  # top_deg <- org_betw %>% sort(decreasing = T) %>% head(nlabelstoshow)
  # V(orgdecadenet)$origlabel <- V(orgdecadenet)$org_limpo
  # 
  # V(orgdecadenet)$label <- if_else(V(orgdecadenet)$name %in% names(top_deg),
  #                                  as.character(V(orgdecadenet)$origlabel), "")
  
  # include betweenness as vertex attribute
  orgdecadenet <- set.vertex.attribute(orgdecadenet, "betw", 
                                       index = V(orgdecadenet), 
                                       betweenness(orgdecadenet,
                                                   normalized = T))
  
  ### Note: 
  # As we will be dealing with centrality measures, we should be aware of a divergence
  # between igraph and other packages (and, I believe, Gephi). Igraph treats edge weight
  # as a measure of cost/friction in relations, not as a strength (measure of capacity/
  # bandwith of the edge). This is NOT what we want.
  # So when we are working with measures that use weight in calculation,
  # we will need to use an inverted measure of weight (1/weight)
  
  E(orgdecadenet)$origweight <- E(orgdecadenet)$weight
  # this makes weight inverted
  E(orgdecadenet)$weight <- 1/E(orgdecadenet)$origweight
  
  # We will maintain this inversion just to calculate betweenness.
  # Then, we will return it to normal, as our layout (Fruchterman Reingold) uses
  # weight in the other way.
  
  org_invbetw <- betweenness(orgdecadenet)
  
  # Only show label if node is among the top largest degree
  top_deg <- org_invbetw %>% sort(decreasing = T) %>% head(nlabelstoshow)
  V(orgdecadenet)$origlabel <- V(orgdecadenet)$org_limpo
  
  V(orgdecadenet)$label <- if_else(V(orgdecadenet)$name %in% names(top_deg),
                                   as.character(V(orgdecadenet)$origlabel), "")
  
  # include betweenness as vertex attribute
  orgdecadenet <- set.vertex.attribute(orgdecadenet, "invbetw", 
                                       index = V(orgdecadenet), 
                                       betweenness(orgdecadenet,
                                                   normalized = T))
  # Return edge weight to the original
  E(orgdecadenet)$invweight <- E(orgdecadenet)$weight
  E(orgdecadenet)$weight <- E(orgdecadenet)$origweight
  
  #.... Coloring nodes by simplified organization type 
  
  index <- data.frame(tipo_org_reduzido = V(orgdecadenet)$tipo_org_reduzido)
  index <- left_join(index, types)
  V(orgdecadenet)$color <- index$color
  V(orgdecadenet)$type <- index$label
  orgdecadenet
}
```

## Colapsando vértices para melhorar visualização e estatísticas
Como o banco de dados foi criado com múltiplos propósitos, as organizações foram classificadas de forma a manter o máximo de distinções entre elas. Assim, órgãos que passam por reformas e mudam de nome muitas vezes são classificados como novas organizações. Como consequência, perdemos algumas informações importantes para avaliar a centralidade das organizações ambientais, que passaram por múltiplas reformas ao longo do tempo (e.g., SEMA, SEMAM-PR, MMA). Em outros casos, podemos ter uma distinção importante para pensar questões administrativas, mas que é pouco relevante para pensar a participação de determinado grupo nas delegações (e.g., Ministério da Marinha vs Marinha do Brasil é pouco relevante para pensar se militares estão presentes ou não).

Para resolver esse problema, podemos colapsar alguns vértices (ie, fundir as organizações), de modo a obter dados mais coerentes com nossos objetivos nessa etapa da pesquisa.


**Checar os relatórios sobre deleg e ver quais foram os órgãos escolhidos para serem colapsados na análise**. No script de redes, colapsei a Marinha (nos anos 70)


## Redes filtradas por mandato presidencial

```{r rede fhc1, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 1995, 1998) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

```

```{r betw fhc1, include=FALSE}
fullstats <- central_stats(orgdecadenet, "betweenness", lglnormal = F, "fhc1") %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "fhc1")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "fhc1", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "fhc1", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "fhc1", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "fhc1", invertweight = F)  )
```

```{r rede fhc2, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 1999, 2002) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

```

```{r betw fhc2, include=FALSE}
fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "fhc2"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "fhc2")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "fhc2", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "fhc2", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "fhc2", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "fhc2", invertweight = F)  )
```

```{r rede lula1, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 2003, 2006) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

```

```{r betw lula1, include=FALSE}
fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "lula1"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "lula1")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "lula1", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "lula1", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "lula1", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "lula1", invertweight = F)  )
```

```{r rede lula2, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 2007, 2010) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

```

```{r betw lula2, include=FALSE}
fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "lula2"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "lula2")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "lula2", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "lula2", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "lula2", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "lula2", invertweight = F)  )
```

```{r rede dilma1, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 2011, 2014) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

```

```{r betw dilma1, include=FALSE}
fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "dilma1"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "dilma1")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "dilma1", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "dilma1", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "dilma1", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "dilma1", invertweight = F)  )
```

```{r rede dilmatemer, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 2015, 2018) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

```

```{r betw dilmatemer, include=FALSE}
fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "dilmatemer"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "dilmatemer")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "dilmatemer", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "dilmatemer", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "dilmatemer", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "eigenvector", T, "dilmatemer", invertweight = F)  )
```


### Visualização das estatísticas por mandato presidencial
(Betweenness, normalized and inverted weights)
```{r plot betwcentrality mandatos, echo = F}
fullstats %>% filter(weightinverted == T & normalized == T) %>% 
  filter(decade %in% c("fhc1", "fhc2", "lula1", "lula2", "dilma1", "dilmatemer")) %>% 
  filter(measure == "betweenness") %>%
  mutate(year = case_when(decade == "fhc1" ~ 1995,
                          decade == "fhc2" ~ 1998,
                          decade == "lula1" ~ 2003,
                          decade == "lula2" ~ 2007,
                          decade == "dilma1" ~ 2011,
                          decade == "dilmatemer" ~ 2015)) %>%
  mutate(org = if_else(is.na(org), "Average", org)) %>% 
  ggplot(aes(x = year, y=value, color = org)) + geom_line() + geom_point() +
  facet_wrap(~org, ncol = 1) +
  scale_x_continuous(name = NULL,
                     breaks = c(1995,1998,2003,2007,2011,2015),
                     label = c("FHC1", "FHC2","Lula1","Lula2","Dilma1","Dilma-Temer")) +
  theme(legend.position = "none", ) +
  ggtitle("Betweenness centrality")
```

(Eigenvector, normalized and inverted weights)
```{r plot betwcentrality mandatos, echo = F}
fullstats %>% filter(weightinverted == T & normalized == T) %>% 
  filter(decade %in% c("fhc1", "fhc2", "lula1", "lula2", "dilma1", "dilmatemer")) %>% 
  filter(measure == "eigenvector") %>% 
  mutate(year = case_when(decade == "fhc1" ~ 1995,
                          decade == "fhc2" ~ 1998,
                          decade == "lula1" ~ 2003,
                          decade == "lula2" ~ 2007,
                          decade == "dilma1" ~ 2011,
                          decade == "dilmatemer" ~ 2015)) %>%
  mutate(org = if_else(is.na(org), "Average", org)) %>% 
  ggplot(aes(x = year, y=value, color = org)) + geom_line() + geom_point() +
  facet_wrap(~org, ncol = 1) +
  scale_x_continuous(name = NULL,
                     breaks = c(1995,1998,2003,2007,2011,2015),
                     label = c("FHC1", "FHC2","Lula1","Lula2","Dilma1","Dilma-Temer")) +
  theme(legend.position = "none", ) +
  ggtitle("Eigenvector centrality")
```
### Tabela das estatísticas por mandato presidencial
```{r tabela betwcentrality mandatos, echo = F}
fullstats %>% filter(weightinverted == T & normalized == T) %>% 
  filter(decade %in% c("fhc1", "fhc2", "lula1", "lula2", "dilma1", "dilmatemer")) %>% 
  filter(measure == "betweenness") %>% 
  mutate(org = if_else(is.na(org), "Average", org)) %>% 
  select(decade, org, value) %>% rename(mandato = decade) %>% 
  knitr::kable(caption = "Betweenness centrality")
```

```{r tabela eigenvector mandatos, echo = F}
fullstats %>% filter(weightinverted == T & normalized == T) %>% 
  filter(decade %in% c("fhc1", "fhc2", "lula1", "lula2", "dilma1", "dilmatemer")) %>% 
  filter(measure == "eigenvector") %>% 
  mutate(org = if_else(is.na(org), "Average", org)) %>% 
  select(decade, org, value) %>% rename(mandato = decade) %>% 
  knitr::kable(caption = "Eigenvector centrality")
```

## Redes filtradas por década
Outra forma de separar os dados é filtrar as redes por décadas.
Aqui, para permitir a comparabilidade no tempo, seria interessante colapsar, no futuro, MMA com outras organizações antecessoras.

Na visualização da rede, estamos usando o algoritmo Fruchterman-Reingold (na implementação do pacote qgraph, feita por meio do pacote multienrichjam - não me lembro exatamente qual era a vantagem da implementação aqui, mas é algo relativo a ajustes como os nós não ficarem tão sobrepostos). O Fruchterman-Reingold é um dos algoritmos mais comuns em visualização de redes, assim como o Kawada-Kawai. No FR, o peso é um fator de atração (mais peso = maior atração, menos peso repele); no KK, a lógica é a inversa, como uma mola (mais peso = mais distância).

```{r install pacote vis, include =FALSE}
# remotes::install_github("jmw86069/multienrichjam", dependencies = T)
```



### Década de 1970
Due to the use of the database for a different purpose, the Ministry of the Navy was originally separated from the Navy as an organization. This is to allow for future ministerial changes (Ministry becomes the Ministry of Defense in the 00s which is not to be confused with the Navy itself). For our purposes, however, this separation does not make any sense. So we need to fuse these vertices.

```{r rede 70s, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 1970, 1979) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

V(orgdecadenet)$combine <- if_else(
  V(orgdecadenet)$org_limpo == "Ministério da Marinha",
  "Marinha do Brasil", #rename Ministério da Marinha to Marinha do Brasil
  V(orgdecadenet)$org_limpo
)
# now combine the two vertices for this network
comb_list <- unique(V(orgdecadenet)$combine)
  
orgdecadenet <- contract(orgdecadenet,
                      mapping = as.numeric(
                        plyr::mapvalues(V(orgdecadenet)$combine, 
                                        from = comb_list, 
                                        to = 1:length(comb_list))
                      ),
                      vertex.attr.comb=list(#methods for combining attributes
                        weight="sum", #sum weights,
                        nparticipations = "sum",  #sum nparticipations
                        "first")) # keep first of others

orgdecadenet <- simplify(orgdecadenet)

fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "70s"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "70s")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "70s", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "70s", invertweight = T)  )
```


```{r plot net 70s, echo = F}
#.... Generating the figure ------

# Creating layout
set.seed(123) #set seed to guarantee reproducibility of figure layout  
# coords <- layout_(orgdecadenet, with_fr())
# coords <- layout_(orgdecadenet, with_kk())
# KK functions as a spring, more weight giving more distance. 
# FR does the opposite: attract when more weight, repels others


spaced_coords <- multienrichjam::layout_with_qfr(orgdecadenet,
                                                 repulse = 3.5,
                                                 repulse.rad = (vcount(orgdecadenet)^3.2)-(2*10^5)
)

# Change labels: name for top5 between orgs
short_lab <- data.frame( long = V(orgdecadenet)$label) %>% filter(long != "")
# short_lab$short <- c("MRE","IPqM","BNH","IBGE","UFRGS")
# n = 10
# short_lab$short <- c("MRE","IPqM","BNH","IBGE", "MDIC", "MAPA","MS","SP","PR","UFRGS")
# n = 30
short_lab$short <- c("IBDF", "MRE", "SUDAM", "EMBRAPA", "UNDP-FAO-IBDF","MInt","IPqM",
                     "BNH", "IBGE", "MDIC", "MAPA", "MS", "SP", "PR", "SEPLAN", 
                     "Senate", "Deputies", "CNI", "SANESP", "Llloyd", "DOCENAVE",
                     "Navy", "Petro", "RDEP", "Syndarma", "SUNAMAM", "UFRGS")

all_labs <- left_join(data.frame( long = V(orgdecadenet)$label),
                      short_lab)


V(orgdecadenet)$longlab <- V(orgdecadenet)$label
V(orgdecadenet)$label <- all_labs$short

# Plotting the figure
par(mar=c(2,1,1,1)+0.1) #set margins for the plot

plot(orgdecadenet,
     # layout = coords, 
     layout = spaced_coords,
     vertex.size = 5 + V(orgdecadenet)$invbetw*10,
     vertex.frame.color = "white",
     vertex.label.color = 'black',
     vertex.label.cex = .8,
     edge.width= 1 + E(orgdecadenet)$weight/15
)

# Including legend
tipos_presentes <- V(orgdecadenet)$type %>% unique
temp_legend <- filter(types, label %in% tipos_presentes)

legend("bottomright",legend=temp_legend$label, 
       col= temp_legend$color,
       bty = "n", pt.cex = 1.2,
       cex = 1, pch=16,
       inset = -0.05, xpd = TRUE
)

# Including title
title("Figure 7. Organizations Network (1970-1979)")

# #.... Saving output -----
# 
# dev.copy(pdf, paste0("Figures/","Fig7", "-",Sys.Date(),".pdf"),
#          width  = par("din")[1]*4,
#          height = par("din")[2]*2.5,
#          #family = "Helvetica-Narrow"
#          )
# dev.off()
```



### Década de 1980

```{r rede 80s, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 1980, 1989) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "80s"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "80s")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "80s", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "80s", invertweight = T)  )
```

```{r plot net 80s, echo = F}
# Creating layout
set.seed(123) #set seed to guarantee reproducibility of figure layout  
# coords <- layout_(orgdecadenet, with_fr())
# coords <- layout_(orgdecadenet, with_kk())
# KK functions as a spring, more weight giving more distance. 
# FR does the opposite: attract when more weight, repels others


spaced_coords <- multienrichjam::layout_with_qfr(orgdecadenet,
                                                 repulse = 3.5,
                                                 repulse.rad = (vcount(orgdecadenet)^3.2)-(2*10^5)
)

# Change labels: name for top between orgs
short_lab <- data.frame( long = V(orgdecadenet)$label) %>% filter(long != "")
short_lab$short <- c("MRE","EMBRAPA","IBDF", "FBCN","IBAMA",
                     "UNDP-FAO-IBDF","SEMAM", "Navy", "USP")
all_labs <- left_join(data.frame( long = V(orgdecadenet)$label),
                      short_lab)


V(orgdecadenet)$longlab <- V(orgdecadenet)$label
V(orgdecadenet)$label <- all_labs$short

# Plotting the figure
par(mar=c(2,1,1,1)+0.1) #set margins for the plot

plot(orgdecadenet,
     #layout = coords, 
      layout = spaced_coords,
     vertex.size = 5 + V(orgdecadenet)$invbetw*10,
     vertex.frame.color = "white",
     vertex.label.color = 'black',
     vertex.label.cex = .9,
     edge.width= 1 + E(orgdecadenet)$weight/15
)

# Including legend
tipos_presentes <- V(orgdecadenet)$type %>% unique
temp_legend <- filter(types, label %in% tipos_presentes)

legend("right",legend=temp_legend$label, 
       col= temp_legend$color,
       bty = "n", pt.cex = 1.2,
       cex = 1, pch=16,
       inset = -0.1, xpd = TRUE
)

# Including title
title("Figure 8. Organizations Network (1980-1989)")

# #.... Saving output -----
# 
# dev.copy(pdf, paste0("Figures/","Fig8", "-",Sys.Date(),".pdf"),
#          width  = par("din")[1]*4,
#          height = par("din")[2]*2.5,
#          #family = "Helvetica-Narrow"
# )
# dev.off()
```



### Década de 1990
Aqui, idealmente, faríamos um collapse dos nós referentes a MMA-SEMAM e SCT-MCT.

```{r rede 90s, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 1990, 1999) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "90s"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "90s")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "90s", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "90s", invertweight = T)  )
```


```{r plot net 90s, echo = F}
# Creating layout
set.seed(123) #set seed to guarantee reproducibility of figure layout  
# coords <- layout_(orgdecadenet, with_fr())
# coords <- layout_(orgdecadenet, with_kk())
# KK functions as a spring, more weight giving more distance. 
# FR does the opposite: attract when more weight, repels others
#for this 70s graph, Kamada-Kawai shows the structure better, as distancing the 
#'main bloc' from MRE allows us to see its structure more clearly

spaced_coords <- multienrichjam::layout_with_qfr(orgdecadenet,
                                                 repulse = 3.5,
                                                 repulse.rad = (vcount(orgdecadenet)^3)-(2*10^5)
)

# Change labels: name for top between orgs
short_lab <- data.frame( long = V(orgdecadenet)$label) %>% filter(long != "")
short_lab$short <- c("MRE", "EMBRAPA", "SCT", "SEMAM", "MMA", "MCT", "MS", "MPOG", "MAPA", "IBAMA", "SP", "ABIQUIM",
                     rep("", 18))
                     # "ABPMEX", "SINDIMAD", "AIMEX", "MinPolFund", "MinIN", "PE", "UFPE", "AL", "FJN", "SUDENE", "DF",
                     # "ABINEE", "USP", "CCSEE", "MDIC", "IBPC", "AEB", "CEBDS")
all_labs <- left_join(data.frame( long = V(orgdecadenet)$label),
                      short_lab)


V(orgdecadenet)$longlab <- V(orgdecadenet)$label
V(orgdecadenet)$label <- all_labs$short

# Plotting the figure
par(mar=c(2,1,1,1)+0.1) #set margins for the plot

plot(orgdecadenet,
     # layout = coords, 
     layout = spaced_coords,
     vertex.size = 3 + V(orgdecadenet)$invbetw*10,
     vertex.frame.color = "white",
     vertex.label.color = 'black',
     vertex.label.cex = .7,
     edge.width= 1 + E(orgdecadenet)$weight/100
)

# Including legend
tipos_presentes <- V(orgdecadenet)$type %>% unique
temp_legend <- filter(types, label %in% tipos_presentes)

legend("bottomright",legend=temp_legend$label, 
       col= temp_legend$color,
       bty = "n", pt.cex = 1.2,
       cex = .7, pch=16,
       inset = -0.05, xpd = TRUE
)

# Including title
title("Figure 9. Organizations Network (1990-1999)")

# #.... Saving output -----
# 
# dev.copy(pdf, paste0("Figures/","Fig9a", "-",Sys.Date(),".pdf"),
#          width  = par("din")[1]*4,
#          height = par("din")[2]*2.5,
#          #family = "Helvetica-Narrow"
# )
# dev.off()
```

#### Filtragem da rede: apenas N+ participações
To clear up the graph and better look at the community structure, it might be more interesting to limit the organizations in the figure. Normally, this would be done by filtering vertex degree (n of connections). This would not be what we want, as someone who participates in only one COP or at UNCED might have a higher degree than someone at 10 smaller events. What we want, instead, is the number of event participations per org as the filter.

*3 ou mais participações da organização*

Idealmente, incluir os nomes das organizações de novo. Como a rede é induzida da rede anterior, já chega com nomes corrigidos (e apagados). Tem alguns que já estavam sem label. Rever código para ver como fazer isso. (É a função prepare nodes?)
```{r plot filtnet90, echo = F}
filtdecadenet <- induced_subgraph(orgdecadenet, 
                 V(orgdecadenet)[nparticipations  >= 3])

set.seed(123)
l <- layout_(filtdecadenet, with_fr())
#kk highlights MRE centrality by pushing it away but makes structure otherwise cluttered
# l <- layout_(filtdecadenet, with_kk()) 

#recalculate betweenness for subcommunity
# filtdecadenet <- set.vertex.attribute(filtdecadenet, "newbetw", 
#                                      index = V(filtdecadenet), 
#                                      betweenness(filtdecadenet, normalized = T))

#not using this in this paper but comparison of newbetw vs general betw is great
#can help identify different functions: eg, some, like MRE, connect inside-outside and
#others connect inside the community. Should remember to use INVERTED WEIGHT as well.

# plot
par(mar=c(2,1,1,1)+0.1) #set margins for the plot

plot(filtdecadenet,
     layout = l, 
     # layout = spaced_coords,
     vertex.size = 3 + V(filtdecadenet)$invbetw*10,
     # vertex.size = 3 + V(filtdecadenet)$newbetw/5,
     vertex.frame.color = "white",
     vertex.label.color = 'black',
     vertex.label.cex = .7,
     edge.width= 1 + E(filtdecadenet)$weight/100
)

title("Figure 11. Filtered Organizations Network (1990-1999, 3+)",
      sub = "Orgs with 3 or more event participations")

# # Save
# dev.copy(pdf, paste0("Figures/","Fig9b", "-",Sys.Date(),".pdf"),
#          width  = par("din")[1]*4,
#          height = par("din")[2]*2.5,
#          #family = "Helvetica-Narrow"
# )
# dev.off()
```



### Década de 2000

```{r rede 00s, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 2000, 2009) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "00s"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "00s")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "00s", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "00s", invertweight = T)  )
```

```{r plot net 00s, echo = F, message = F}
# Creating layout
set.seed(123) #set seed to guarantee reproducibility of figure layout  
# coords <- layout_(orgdecadenet, with_fr())
# coords <- layout_(orgdecadenet, with_kk())


# KK functions as a spring, more weight giving more distance. 
# FR does the opposite: attract when more weight, repels others

spaced_coords <- multienrichjam::layout_with_qfr(orgdecadenet,
                                                 repulse = 3.5,
                                                 repulse.rad = (vcount(orgdecadenet)^2.4)-(4*10^5)
)

# Change labels: name for top between orgs
short_lab <- data.frame( long = V(orgdecadenet)$label) %>% filter(long != "")
short_lab$short <- c("MRE","MAPA","MMA", "MDIC","MCT",
                     "CEBDS","FBOMS", "Senado", "IBAMA","MS",
                     # rep("",20)
                     "Palmares","Vitae","CONTAG","MD","CNI","MG","PR","GO",
                     "MinC", "BNDES","ES","UEAM","PRRI","ABIA","SP","AC","SC",
                     "UFRJ","Câmara","Marinha"
                     )
all_labs <- left_join(data.frame( long = V(orgdecadenet)$label),
                      short_lab)


V(orgdecadenet)$longlab <- V(orgdecadenet)$label
V(orgdecadenet)$label <- all_labs$short
# Manually include relevant labels
V(orgdecadenet)[id_org_unica == 435]$label <- "MRE"
V(orgdecadenet)[id_org_unica == 442]$label <- "MMA"
V(orgdecadenet)[id_org_unica == 422]$label <- "MCT"
V(orgdecadenet)[id_org_unica == 421]$label <- "MAPA"



# Plotting the figure
par(mar=c(2,1,1,1)+0.1) #set margins for the plot

plot(orgdecadenet,
     # layout = coords, 
     layout = spaced_coords,
     vertex.size = 3 + V(orgdecadenet)$invbetw*10,
     vertex.frame.color = "white",
     vertex.label.color = 'black',
     vertex.label.cex = .7,
     edge.width= 1 + E(orgdecadenet)$weight/2700
)

# Including legend
tipos_presentes <- V(orgdecadenet)$type %>% unique
temp_legend <- filter(types, label %in% tipos_presentes)

legend("right",legend=temp_legend$label, 
       col= temp_legend$color,
       bty = "n", pt.cex = 1.2,
       cex = .7, pch=16,
       inset = -0.05, xpd = TRUE
)

# Including title
title("Figure 10. Organizations Network (2000-2009)")

# #.... Saving output -----
# dev.copy(pdf, paste0("Figures/","Fig10a", "-",Sys.Date(),".pdf"),
#          width  = par("din")[1]*4,
#          height = par("din")[2]*2.5,
#          #family = "Helvetica-Narrow"
# )
# dev.off()
```

#### Filtragem da rede: apenas N+ participações
To clear up the graph and better look at the community structure, it might be more interesting to limit the organizations in the figure. Normally, this would be done by filtering vertex degree (n of connections). This would not be what we want, as someone who participates in only one COP or at UNCED might have a higher degree than someone at 10 smaller events. What we want, instead, is the number of event participations per org as the filter.

*10 ou mais participações da organização*

Idealmente, incluir os nomes das organizações de novo. Como a rede é induzida da rede anterior, já chega com nomes corrigidos (e apagados). Tem alguns que já estavam sem label. Rever código para ver como fazer isso. (É a função prepare nodes?)

```{r plot filtnet 00s, echo = F}
#.... Alternative figure: only orgs with 10+ participations -----
# To clear up the graph and better look at the community structure, 
# it might be more interesting to limit the organizations in the figure.
# Normally, this would be done by filtering vertex degree (n of connections).
# This would not be what we want, as someone who participates in only one COP or at UNCED
# might have a higher degree than someone at 10 smaller events.
# What we want, instead, is the number of event participations per org as the filter.

filtdecadenet <- induced_subgraph(orgdecadenet, 
                                  V(orgdecadenet)[nparticipations  >= 10])

set.seed(123)
# l <- layout_(filtdecadenet, with_kk()) 
# l <- layout_(filtdecadenet, with_fr())
l <- multienrichjam::layout_with_qfr(filtdecadenet,
                                                 repulse = 3.5,
                                                 repulse.rad = (vcount(orgdecadenet)^2.3)-(4*10^5)
                                     )


# l <- layout_nicely(filtdecadenet)

#recalculate betweenness for subcommunity
# filtdecadenet <- set.vertex.attribute(filtdecadenet, "newbetw", 
#                                       index = V(filtdecadenet), 
#                                       betweenness(filtdecadenet, normalized = T))

#not using this in this paper but comparison of newbetw vs general betw is great
#can help identify different functions: eg, some, like MRE, connect inside-outside and
#others connect inside the community. Remember to INVERT WEIGHTS.

# plot
par(mar=c(2,1,1,1)+0.1) #set margins for the plot

plot(filtdecadenet,
     layout = multienrichjam::rotate_igraph_layout(layout = l, degrees = 45), 
     # layout = spaced_coords,
     vertex.size = 3 + V(filtdecadenet)$invbetw*10,
     # vertex.size = 3 + V(filtdecadenet)$newbetw/5,
     vertex.frame.color = "white",
     vertex.label.color = 'black',
     vertex.label.cex = .7,
     edge.width= 1 + E(filtdecadenet)$weight/2700
)

title("Figure 12. Filtered Organizations Network (2000-2009, 10+)",
      sub = "Orgs with 10 or more event participations")

# # Save
# dev.copy(pdf, paste0("Figures/","Fig10b", "-",Sys.Date(),".pdf"),
#          width  = par("din")[1]*4,
#          height = par("din")[2]*2.5,
#          #family = "Helvetica-Narrow"
# )
# dev.off()
```


### Década de 2010
```{r rede 10s, include=FALSE}
orgdecadenet <- yearfilter_net(personyrNet, 2010, 2018) %>% 
  collapse_ind2org() %>% preparing_nodeappearance(30)

fullstats <- fullstats %>% 
  bind_rows(central_stats(orgdecadenet, "betweenness", lglnormal = F, "10s"))   %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "10s")  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", F, "10s", invertweight = T)  ) %>% 
  bind_rows( central_stats(orgdecadenet, "betweenness", T, "10s", invertweight = T)  )
```

```{r plot net 10s, echo = F, message = F}
# Creating layout
set.seed(123) #set seed to guarantee reproducibility of figure layout  
# coords <- layout_(orgdecadenet, with_fr())
# coords <- layout_(orgdecadenet, with_kk())


# KK functions as a spring, more weight giving more distance. 
# FR does the opposite: attract when more weight, repels others

spaced_coords <- multienrichjam::layout_with_qfr(orgdecadenet,
                                                 repulse = 3.5,
                                                 repulse.rad = (vcount(orgdecadenet)^2.4)-(4*10^5)
)

# Change labels: name for top between orgs
short_lab <- data.frame( long = V(orgdecadenet)$label) %>% filter(long != "")
short_lab$short <- c("MRE","MMA", "IBAMA", "ANVISA", "MAPA","MS",
                     rep("",24)
                     # "ABREA","SP","UEL","Delbrasgen","ICMBIO","SFB",
                     # "EMBRAPA","BNDES","MPA", "MPS","MTE","SGPR",
                     # "SPM","MCT","MEsp","MFaz", "MME","SECOM",
                     # "SRI","MCOM","CC-PR","AC","Câmara","CEBDS"
                     )
all_labs <- left_join(data.frame( long = V(orgdecadenet)$label),
                      short_lab)


V(orgdecadenet)$longlab <- V(orgdecadenet)$label
V(orgdecadenet)$label <- all_labs$short
# Manually include relevant labels
V(orgdecadenet)[id_org_unica == 435]$label <- "MRE"
V(orgdecadenet)[id_org_unica == 442]$label <- "MMA"
V(orgdecadenet)[id_org_unica == 422]$label <- "MCT"
V(orgdecadenet)[id_org_unica == 421]$label <- "MAPA"



# Plotting the figure
par(mar=c(2,1,1,1)+0.1) #set margins for the plot

plot(orgdecadenet,
     # layout = coords, 
     layout = spaced_coords,
     vertex.size = 3 + V(orgdecadenet)$invbetw*10,
     vertex.frame.color = "white",
     vertex.label.color = 'black',
     vertex.label.cex = .7,
     edge.width= 1 + E(orgdecadenet)$weight/2700
)

# Including legend
tipos_presentes <- V(orgdecadenet)$type %>% unique
temp_legend <- filter(types, label %in% tipos_presentes)

legend("bottomright",legend=temp_legend$label, 
       col= temp_legend$color,
       bty = "n", pt.cex = 1.2,
       cex = .7, pch=16,
       inset = -0.05, xpd = TRUE
)

# Including title
title("Figure. Organizations Network (2010-2018)")

# #.... Saving output -----
# dev.copy(pdf, paste0("Figures/","Fig10a", "-",Sys.Date(),".pdf"),
#          width  = par("din")[1]*4,
#          height = par("din")[2]*2.5,
#          #family = "Helvetica-Narrow"
# )
# dev.off()
```

#### Filtragem da rede: apenas N+ participações
To clear up the graph and better look at the community structure, it might be more interesting to limit the organizations in the figure. Normally, this would be done by filtering vertex degree (n of connections). This would not be what we want, as someone who participates in only one COP or at UNCED might have a higher degree than someone at 10 smaller events. What we want, instead, is the number of event participations per org as the filter.

*10 ou mais participações da organização*

Idealmente, incluir os nomes das organizações de novo. Como a rede é induzida da rede anterior, já chega com nomes corrigidos (e apagados). Tem alguns que já estavam sem label. Rever código para ver como fazer isso. (É a função prepare nodes?)

```{r plot filtnet 10s, echo = F}
#.... Alternative figure: only orgs with 10+ participations -----
# To clear up the graph and better look at the community structure, 
# it might be more interesting to limit the organizations in the figure.
# Normally, this would be done by filtering vertex degree (n of connections).
# This would not be what we want, as someone who participates in only one COP or at UNCED
# might have a higher degree than someone at 10 smaller events.
# What we want, instead, is the number of event participations per org as the filter.

filtdecadenet <- induced_subgraph(orgdecadenet, 
                                  V(orgdecadenet)[nparticipations  >= 10])

set.seed(123)
# l <- layout_(filtdecadenet, with_kk()) 
# l <- layout_(filtdecadenet, with_fr())
l <- multienrichjam::layout_with_qfr(filtdecadenet,
                                                 repulse = 3.5,
                                                 repulse.rad = (vcount(orgdecadenet)^2.3)-(4*10^5)
                                     )


# l <- layout_nicely(filtdecadenet)

#recalculate betweenness for subcommunity
# filtdecadenet <- set.vertex.attribute(filtdecadenet, "newbetw", 
#                                       index = V(filtdecadenet), 
#                                       betweenness(filtdecadenet, normalized = T))

#not using this in this paper but comparison of newbetw vs general betw is great
#can help identify different functions: eg, some, like MRE, connect inside-outside and
#others connect inside the community. Remember to INVERT WEIGHTS.

# plot
par(mar=c(2,1,1,1)+0.1) #set margins for the plot

plot(filtdecadenet,
     layout = multienrichjam::rotate_igraph_layout(layout = l, degrees = 45), 
     # layout = spaced_coords,
     vertex.size = 3 + V(filtdecadenet)$invbetw*10,
     # vertex.size = 3 + V(filtdecadenet)$newbetw/5,
     vertex.frame.color = "white",
     vertex.label.color = 'black',
     vertex.label.cex = .7,
     edge.width= 1 + E(filtdecadenet)$weight/2700
)

title("Figure. Filtered Organizations Network (2010-2018, 10+)",
      sub = "Orgs with 10 or more event participations")

# # Save
# dev.copy(pdf, paste0("Figures/","Fig10b", "-",Sys.Date(),".pdf"),
#          width  = par("din")[1]*4,
#          height = par("din")[2]*2.5,
#          #family = "Helvetica-Narrow"
# )
# dev.off()
```


```{r plot filtnet 10s 20plus, echo = F}
#.... Alternative figure: only orgs with 10+ participations -----
# To clear up the graph and better look at the community structure, 
# it might be more interesting to limit the organizations in the figure.
# Normally, this would be done by filtering vertex degree (n of connections).
# This would not be what we want, as someone who participates in only one COP or at UNCED
# might have a higher degree than someone at 10 smaller events.
# What we want, instead, is the number of event participations per org as the filter.

filtdecadenet <- induced_subgraph(orgdecadenet, 
                                  V(orgdecadenet)[nparticipations  >= 20])

set.seed(123)
# l <- layout_(filtdecadenet, with_kk()) 
# l <- layout_(filtdecadenet, with_fr())
l <- multienrichjam::layout_with_qfr(filtdecadenet,
                                                 repulse = 3.5,
                                                 repulse.rad = (vcount(orgdecadenet)^2.3)-(4*10^5)
                                     )


# l <- layout_nicely(filtdecadenet)

#recalculate betweenness for subcommunity
# filtdecadenet <- set.vertex.attribute(filtdecadenet, "newbetw", 
#                                       index = V(filtdecadenet), 
#                                       betweenness(filtdecadenet, normalized = T))

#not using this in this paper but comparison of newbetw vs general betw is great
#can help identify different functions: eg, some, like MRE, connect inside-outside and
#others connect inside the community. Remember to INVERT WEIGHTS.

# plot
par(mar=c(2,1,1,1)+0.1) #set margins for the plot

plot(filtdecadenet,
     layout = multienrichjam::rotate_igraph_layout(layout = l, degrees = 45), 
     # layout = spaced_coords,
     vertex.size = 3 + V(filtdecadenet)$invbetw*10,
     # vertex.size = 3 + V(filtdecadenet)$newbetw/5,
     vertex.frame.color = "white",
     vertex.label.color = 'black',
     vertex.label.cex = .7,
     edge.width= 1 + E(filtdecadenet)$weight/2700
)

title("Figure. Filtered Organizations Network (2010-2018, 20+)",
      sub = "Orgs with 20 or more event participations")

# # Save
# dev.copy(pdf, paste0("Figures/","Fig10b", "-",Sys.Date(),".pdf"),
#          width  = par("din")[1]*4,
#          height = par("din")[2]*2.5,
#          #family = "Helvetica-Narrow"
# )
# dev.off()
```




## Visualização das estatísticas por década
(Betweenness, normalized and inverted weights)
```{r plot betwcentrality mandatos, echo = F}
fullstats %>% filter(weightinverted == T & normalized == T) %>% 
  filter(decade %in% c("70s","80s","90s","00s","10s")) %>% 
  mutate(year = case_when(decade == "70s" ~ 1970,
                          decade == "80s" ~ 1980,
                          decade == "90s" ~ 1990,
                          decade == "00s" ~ 2000,
                          decade == "10s" ~ 2010)) %>%
  mutate(org = if_else(is.na(org), "Average", org)) %>% 
  ggplot(aes(x = year, y=value, color = org)) + geom_line() + geom_point() +
  facet_wrap(~org, ncol = 1) +
  scale_x_continuous(name = NULL,
                     breaks = c(1970,1980,1990,2000,2010),
                     label = c("70s","80s","90s","00s","10s")) +
  theme(legend.position = "none", ) +
  ggtitle("Betweenness centrality")
```

### Tabela das estatísticas por mandato presidencial
```{r tabela betwcentrality mandatos, echo = F}
fullstats %>% filter(weightinverted == T & normalized == T) %>% 
  mutate(org = if_else(is.na(org), "Average", org)) %>% 
  filter(decade %in% c("70s","80s","90s","00s","10s")) %>% 
  select(decade, org, value) %>%
  knitr::kable(caption = "Betweenness centrality")
```

## Estatísticas da rede em janelas móveis de 4 anos
Observar a rede ano-a-ano é problemático, porque há muitos eventos que são bianuais e a rede variaria muito de ano a ano. Ter um valor de centralidade para cada ano, porém, viabiliza uma série de análises.
Para calcular a centralidade de modo a construir valores para cada ano, uma alternativa é montar janelas móveis para as redes. Isto é, para cada ano, veríamos a centralidade na rede formada pelos eventos daquele ano + os eventos de até N anos atrás (Note-se que, como mínimo e máximo são incluídos, temos N+1 anos na rede). Isso permite incorporar, também, a ideia de que os laços estabelecidos em eventos anteriores também 'se perdem' se não são renovados ao longo do tempo.

Para calcular a centralidade com as janelas móveis, usaremos as funções definidas anteriormente (filtro de rede por ano e cálculo da centralidade). Ao invés de incluir os dados manualmente, porém, vamos aplicá-los a partir de uma função.

```{r funcao janela movel, include = F, message = FALSE}

calcularcent_janela <- function(ano_inicial, tamanho_janela = 3){
  net <- yearfilter_net(personyrNet, ano_inicial - tamanho_janela, ano_inicial) %>% 
  collapse_ind2org()
  central_stats(net, "betweenness", T, ano_inicial, invertweight = T)
  # importante normalizar p/ comparar entre redes!
}

full_centr3 <- map_df(1973:2018, calcularcent_janela)
```

### Centralidade de intermediação (betweenness)

#### Visualização de betweenness
```{r plot betw jan4, echo = F}
full_centr3 %>% 
  mutate(org = if_else(is.na(org), "Average", org)) %>% 
  ggplot(aes(x = decade, y=value, color = org)) +
  geom_line() + geom_point() +
  facet_wrap(~org, ncol = 1) +
  theme(legend.position = "none") +
  ggtitle("Normalized betweenness centrality, 4 year window network")
```


#### Tabela dados betweenness
```{r tabela betwcentrality jan4, echo = F}
full_centr3 %>% mutate(org = if_else(is.na(org), "Average", org)) %>% 
  select(decade, org, value) %>% rename(year = decade) %>% 
  knitr::kable(caption = "Normalized betweenness centrality, 4 year window network")
```